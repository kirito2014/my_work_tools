<!DOCTYPE HTML>
<HTML class=" no-details"><HEAD> <TITLE></TITLE> 
<SCRIPT>
!function(e,t){"function"==typeof define&&define.amd?define(t):"object"==typeof exports?module.exports=t():t()}(0,function(){var o="details",i="summary";(function(){var e=document.createElement(o);if(!("open"in e))return!1;e.innerHTML="<"+i+">a</"+i+">b",document.body.appendChild(e);var t=e.offsetHeight;e.open=!0;var n=t!=e.offsetHeight;return document.body.removeChild(e),n})()||(document.documentElement.className+=" no-details",window.addEventListener("click",function(e){if("summary"===e.target.nodeName.toLowerCase()){var t=e.target.parentNode;if(!t)return;t.getAttribute("open")?(t.open=!1,t.removeAttribute("open")):(t.open=!0,t.setAttribute("open","open"))}}),function(e,t){if(document.getElementById(e))return;var n=document.createElement("style");n.id=e,n.innerHTML=t,document.getElementsByTagName("head")[0].appendChild(n)}("details-polyfill-style","html.no-details "+o+":not([open]) > :not("+i+") { display: none; }\nhtml.no-details "+o+" > "+i+':before { content: "▶"; display: inline-block; font-size: .8em; width: 1.5em; }\nhtml.no-details '+o+"[open] > "+i+':before { content: "▼"; }'))});
//# sourceMappingURL=/sm/553b125cee29bdb941065007e0203c54a036857cf6e81a93ee381477b77eeaf7.map
</SCRIPT>

<STYLE id="details-polyfill-style">html.no-details details:not([open]) > :not(summary) { display: none; }
html.no-details details > summary:before { content: "▶"; display: inline-block; font-size: .8em; width: 1.5em; }
html.no-details details[open] > summary:before { content: "▼"; }</STYLE>
 
<STYLE type="text/css">
body {
    font-family: Helvetica, arial, sans-serif;
    font-size: 10.5pt;
    line-height: 1.6;
    padding-top: 10px;
    padding-bottom: 10px;
    background-color: white;
    padding: 30px; 
}

body > *:first-child {
    margin-top: 0 !important; 
}

body > *:last-child {
    margin-bottom: 0 !important; 
}

details summary {
    cursor:pointer; 
     font-size: 12pt; 
}

details p{
  white-space:pre-line;  
}

a {
    color: #4183C4; 
}

a.absent {
    color: #cc0000; 
}

a.anchor {
    display: block;
    padding-left: 30px;
    margin-left: -30px;
    cursor: pointer;
    position: absolute;
    top: 0;
    left: 0;
    bottom: 0; 
}
h1, h2, h3, h4, h5, h6 {
	line-height: 1.5em;
    margin: 20px 0 10px;
    padding: 0;
    font-weight: bold;
    -webkit-font-smoothing: antialiased;
    cursor: text;
    position: relative; 
}
h1:hover a.anchor, h2:hover a.anchor, h3:hover a.anchor, h4:hover a.anchor, h5:hover a.anchor, h6:hover a.anchor {
    text-decoration: none; 
}
h1 tt, h1 code {
    font-size: inherit; 
}
h2 tt, h2 code {
    font-size: inherit; 
}
h3 tt, h3 code {
    font-size: inherit; 
}
h4 tt, h4 code {
    font-size: inherit; 
}
h5 tt, h5 code {
    font-size: inherit; 
}
h6 tt, h6 code {
    font-size: inherit; 
}
h1 {
    font-size: 18pt;
    color: black; 
    border-bottom: none;
	padding-bottom: 3px;
	text-align:center;
}
h2 {
    font-size: 13.5pt;
    padding-bottom: 3px;
    border-bottom: 3px solid #eee;
    color: #444;
}
h3 {
    font-size: 12.7pt; 
    border-bottom: 2px solid #ccc;
    color: #555;
}
h4 {
    font-size: 16px; 
    border-bottom: 1px solid #ccc;
    color: #666;
}
h5 {
    font-size: 15px; 
    border-bottom: 1px dotted #ccc;
    color: #777;
}
h6 {
    font-size: 14px; 
    border-bottom: 1px dotted #793862;
    color: #793862;
}
p, blockquote, ul, ol, dl, li, table, pre {
    margin: 15px 0; 
}
hr {
    border: 0 none;
    color: #cccccc;
    height: 4px;
    padding: 0; 
}

body > h2:first-child {
    margin-top: 0;
    padding-top: 0; 
}
body > h1:first-child {
    margin-top: 0;
    padding-top: 0;
}
body > h1:first-child + h2 {
    margin-top: 0;
    padding-top: 0; 
}
body > h3:first-child, body > h4:first-child, body > h5:first-child, body > h6:first-child {
    margin-top: 0;
    padding-top: 0; 
}
a:first-child h1, a:first-child h2, a:first-child h3, a:first-child h4, a:first-child h5, a:first-child h6 {
    margin-top: 0;
    padding-top: 0; 
}
h1 p, h2 p, h3 p, h4 p, h5 p, h6 p {
    margin-top: 0; }

li p.first {
    display: inline-block; 
}
ul, ol {
    padding-left: 30px; 
}
ul :first-child, ol :first-child {
    margin-top: 0; 
}
ul :last-child, ol :last-child {
    margin-bottom: 0; 
}
dl {
    padding: 0; 
}
dl dt {
    font-size: 14px;
    font-weight: bold;
    font-style: italic;
    padding: 0;
    margin: 15px 0 5px; 
}
dl dt:first-child {
    padding: 0; 
}
dl dt > :first-child {
    margin-top: 0; 
}
dl dt > :last-child {
    margin-bottom: 0; 
}
dl dd {
    margin: 0 0 15px;
    padding: 0 15px; 
}
dl dd > :first-child {
    margin-top: 0; 
}
dl dd > :last-child {
    margin-bottom: 0; 
}
blockquote {
    border-left: 4px solid #dddddd;
    padding: 0 15px;
    color: #777777; 
}
blockquote > :first-child {
    margin-top: 0; 
}
blockquote > :last-child {
    margin-bottom: 0; 
}
table {
    padding: 0; 
}
table tr {
    border-top: 1px solid #cccccc;
    background-color: white;
    margin: 0;
    padding: 0; 
}
table tr:nth-child(2n) {
    background-color: #f8f8f8; 
}
table tr th {
    font-weight: bold;
    border: 1px solid #cccccc;
    text-align: left;
    margin: 0;
    padding: 6px 13px; 
}
table tr td {
    border: 1px solid #cccccc;
    text-align: left;
    margin: 0;
    padding: 6px 13px; 
}
table tr th :first-child, table tr td :first-child {
    margin-top: 0; 
}
table tr th :last-child, table tr td :last-child {
    margin-bottom: 0; 
}
img {
    max-width: 100%; 
}
span.frame {
    display: block;
    overflow: hidden; 
}
span.frame > span {
    border: 1px solid #dddddd;
    display: block;
    float: left;
    overflow: hidden;
    margin: 13px 0 0;
    padding: 7px;
    width: auto; 
}
span.frame span img {
    display: block;
    float: left; 
 }
span.frame span span {
    clear: both;
    color: #333333;
    display: block;
    padding: 5px 0 0; 
}
span.align-center {
    display: block;
    overflow: hidden;
    clear: both; 
}
span.align-center > span {
    display: block;
    overflow: hidden;
    margin: 13px auto 0;
    text-align: center; 
}
span.align-center span img {
    margin: 0 auto;
    text-align: center; 
 }
span.align-right {
    display: block;
    overflow: hidden;
    clear: both; 
}
span.align-right > span {
    display: block;
    overflow: hidden;
    margin: 13px 0 0;
    text-align: right; 
}
span.align-right span img {
    margin: 0;
    text-align: right; 
}
span.float-left {
    display: block;
    margin-right: 13px;
    overflow: hidden;
    float: left; 
}
span.float-left span {
    margin: 13px 0 0; 
}
span.float-right {
    display: block;
    margin-left: 13px;
    overflow: hidden;
    float: right; 
}
span.float-right > span {
    display: block;
    overflow: hidden;
    margin: 13px auto 0;
    text-align: right; 
}
code, tt {
    margin: 0 2px;
    padding: 0 5px;
    white-space: nowrap;
    border: 1px solid #eaeaea;
    background-color: #f8f8f8;
    border-radius: 3px; 
}
pre code {
    margin: 0;
    padding: 0;
    white-space: pre;
    border: none;
    background: transparent; 
}
.highlight pre {
    background-color: #f8f8f8;
    border: 1px solid #cccccc;
    font-size: 13px;
    line-height: 19px;
    overflow: auto;
    padding: 6px 10px;
    border-radius: 3px; 
}
pre {
    background-color: #f8f8f8;
    border: 1px solid #cccccc;
    font-size: 13px;
    line-height: 19px;
    overflow: auto;
    padding: 6px 10px;
    border-radius: 3px; 
}
pre code, pre tt {
    background-color: transparent;
    border: none; 
}
</STYLE>
 </HEAD><BODY><!--StartFragment--><H1>ODL 语法帮助文档</H1><BLOCKQUOTE><P>在 aardio 中一般不需要改动 *.odl 类型库声明文件。 保持默认就可以，所有接口函数可用 com.activeX 自动导出。</P><P>如果要自定义类型库，建议继承 aardio.idl 提供的 IDispeatchExecutable 接口。 所有 DISPID 不应大于 10000 （aardio 自动生成 DISPID 以 10000 为起始值递增）。</P><P>所有 aardio 表对象、函数对象都实现了 IDispatch 接口， 表对象可在 DISPID_NEWENUM 调用时返回 IEnumVARIANT 枚举接口。</P></BLOCKQUOTE><H2>一、定义类型库（library）</H2><H3>1.1 语法</H3><PRE><CODE class="odl">[attributes]
library 类型库名 { 
    importlib("库名");
    [attributes]
    interface/interface_name : IDispatch { 
        函数定义;
    };
};
</CODE></PRE><H3>1.2 语法元素说明</H3><UL><LI><CODE>attributes</CODE>: 可以包括 <CODE>helpstring</CODE>, <CODE>helpcontext</CODE>, <CODE>lcid</CODE>, <CODE>restricted</CODE>, <CODE>hidden</CODE>, <CODE>control</CODE>, <CODE>uuid</CODE>, <CODE>version</CODE> 属性，其中 <CODE>uuid</CODE> 是必须的。</LI><LI><CODE>library</CODE>: 类型库的名字。</LI><LI><CODE>importlib</CODE>: 引入标准库。</LI><LI><CODE>interface</CODE>: 接口定义。</LI></UL><H3>1.3 备注</H3><UL><LI><CODE>library</CODE> 表达式必须出现在任何类型定义之前。</LI></UL><H3>1.4 示例</H3><PRE><CODE class="odl">import "aardio.idl";

[
uuid(27A24EA2-F236-4FE4-A918-44AAB7A8DC5C),
version(1.0)
]
library aardioTestControl {

    importlib("stdole32.tlb");    

    [ uuid(EC32DF0E-0947-4DF1-827D-7073D376995D),control ]
    coclass Sample {

        //默认接口
        [default] dispinterface IDispatchExecutable;

        //默认事件源接口
        [default,source] dispinterface IDispatchExecutableEvent;
    }; 
};
</CODE></PRE><H2>二、定义自动化接口（dispinterface）</H2><H3>2.1 语法</H3><PRE><CODE class="odl">[attributes]
dispinterface 接口名 { 
    函数列表 
};
</CODE></PRE><H3>2.2 语法元素说明</H3><UL><LI><CODE>attributes</CODE>:  一般只要指定 <CODE>uuid</CODE> 就可以了。</LI><LI><CODE>functionlist</CODE>: 接口中每个函数的原型列表。</LI></UL><H3>2.3 函数定义</H3><PRE><CODE class="odl">[attributes] returntype [calling convention] funcname(params);
</CODE></PRE><UL><LI><CODE>attributes</CODE>: 可包括 <CODE>helpstring</CODE>, <CODE>helpcontext</CODE>, <CODE>string</CODE>, <CODE>propget</CODE>, <CODE>propput</CODE>, <CODE>propputref</CODE>, <CODE>bindable</CODE>, <CODE>defaultbind</CODE>, <CODE>displaybind</CODE>, <CODE>vararg</CODE> 等。</LI><LI><CODE>params</CODE>: 参数列表，可以包括 <CODE>in</CODE>, <CODE>out</CODE>, <CODE>optional</CODE>, <CODE>string</CODE> 属性。</LI></UL><H3>2.4 备注</H3><UL><LI>aardio 里最常用的是 dispinterface 接口，否则必须是继承自 IDispatch 的自动化接口。</LI><LI>dispinterface 接口不能继承自其他接口（因为必须继承自IDispatch）。</LI><LI>dispinterface 不需要要在最后一个参数指定返回值，并且也不需要返回  <CODE>HRESULT</CODE> 值，而是直接指定实际需要的返回值就可以了。</LI><LI>添加 [out] 标记参数能声明输出参数，实际上 COM 接口很少用这种输出参数，直接使用返回值更简单。</LI><LI>所有 DISPID 的值必须小于 10000 并大于等于 0 ，大于 10000 的 DISPID 由 aardio 自动分配。</LI></UL><H3>2.5 示例</H3><PRE><CODE class="odl">    [ uuid(1C8736BC-8C0C-4DB6-9FAD-1C6A0CDF1FA2) ]
    dispinterface  IDispatchSample{ 
        properties:
        methods:  
            [ id(10) ]
            void Test( [in] BSTR str,[in,out] VARIANT *out1,[in,out] VARIANT *out2);
    } 
</CODE></PRE><H2>三、定义接口（interface）</H2><H3>2.1 语法</H3><PRE><CODE class="odl">[attributes]
interface 接口名 [: 父接口名] { 
    函数列表 
};
</CODE></PRE><H3>2.2 语法元素说明</H3><UL><LI><CODE>attributes</CODE>: 可以包括 <CODE>dual</CODE>, <CODE>helpstring</CODE>, <CODE>helpcontext</CODE>, <CODE>hidden</CODE>, <CODE>odl</CODE>, <CODE>oleautomation</CODE>, <CODE>uuid</CODE>, <CODE>version</CODE> 属性，其中 <CODE>odl</CODE> 和 <CODE>uuid</CODE> 是必须的。</LI><LI><CODE>functionlist</CODE>: 接口中每个函数的原型列表。</LI></UL><H3>2.3 函数定义</H3><PRE><CODE class="odl">[attributes] returntype [calling convention] funcname(params);
</CODE></PRE><UL><LI><CODE>attributes</CODE>: 可包括 <CODE>helpstring</CODE>, <CODE>helpcontext</CODE>, <CODE>string</CODE>, <CODE>propget</CODE>, <CODE>propput</CODE>, <CODE>propputref</CODE>, <CODE>bindable</CODE>, <CODE>defaultbind</CODE>, <CODE>displaybind</CODE>, <CODE>vararg</CODE> 等。</LI><LI><CODE>params</CODE>: 参数列表，可以包括 <CODE>in</CODE>, <CODE>out</CODE>, <CODE>optional</CODE>, <CODE>string</CODE> 属性。</LI></UL><H3>2.4 备注</H3><UL><LI>接口里的函数返回 <CODE>HRESULT</CODE> 值，真实返回值指定为返回参数，始终是最后一个参数。</LI><LI>双重接口必须从 <CODE>IDispatch</CODE> 继承。</LI></UL><H3>2.5 示例</H3><PRE><CODE class="odl">[uuid(BFB73347-822A-1068-8849-00DD011087E8), version(1.0)]
interface Hello : IUnknown { 
    void HelloProc([in, string] unsigned char* pszString); 
    void Shutdown(void); 
};

[dual]
interface IMyInt : IDispatch { 
    [propget] HRESULT MyMessage([in, lcid] LCID lcid, [out, retval] BSTR* pbstrRetVal); 
    [propput] HRESULT MyMessage([in] BSTR rhs, [in, lcid] DWORD lcid);
    HRESULT SayMessage([in] long NumTimes, [in, lcid] DWORD lcid, [out, retval] BSTR* pbstrRetVal); 
}
</CODE></PRE><H2>四、定义组件类（coclass）</H2><H3>3.1 语法</H3><PRE><CODE class="odl">[attributes]
coclass 类名 { 
    [attributes2] [interface | dispinterface] 接口名; 
};
</CODE></PRE><H3>3.2 语法元素说明</H3><UL><LI><CODE>attributes</CODE>: <CODE>uuid</CODE> 属性是必须的，其它属性包括 <CODE>helpstring</CODE>, <CODE>helpcontext</CODE>, <CODE>version</CODE>, <CODE>licensed</CODE>, <CODE>control</CODE>, <CODE>hidden</CODE>, <CODE>appobject</CODE> 等。</LI><LI><CODE>attributes2</CODE>: <CODE>interface</CODE> 或 <CODE>dispinterface</CODE> 的可选属性，包括 <CODE>source</CODE>, <CODE>default</CODE>, <CODE>restricted</CODE> 等。</LI><LI><CODE>interfacename</CODE>: 用 <CODE>interface</CODE> 或 <CODE>dispinterface</CODE> 声明的接口名。</LI></UL><H3>3.3 备注</H3><UL><LI><CODE>coclass</CODE> 定义一个类作为一个实现，允许 <CODE>QueryInterface</CODE> 在接口集之间查询。</LI></UL><H3>3.4 示例</H3><PRE><CODE class="odl">[uuid(BFB73347-822A-1068-8849-00DD011087E8), version(1.0), helpstring("A class"), helpcontext(2481), appobject]
coclass myapp {
    [source] interface IMydocfuncs; 
    dispinterface DMydocfuncs; 
};

[uuid(00000000-0000-0000-0000-123456789019)]
coclass foo {
    [restricted] interface bar;
    interface bar;
}
</CODE></PRE><P>此文档精简了 ODL 语法的关键要素，便于快速入门和掌握基本写法。</P><!--EndFragment--></BODY></HTML>
